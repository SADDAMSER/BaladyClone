@extends('layouts.drawinglayout', ['title' => translate('printorder_no') . '_' . $order->order_no])
@php
    $dirname = $unitinfo->unitname_en;
    $unit_raster_path = asset('uploads/units_restor/' . $dirname . '/map.png');
    $json_file_path = public_path('uploads/units_restor/' . $dirname . '/bounds.json');
    $unit_raster_path = asset('uploads/units_restor/' . $dirname . '/map.png');
DD($unit_raster_path);
    if (file_exists($json_file_path)) {
        $jsoinfo = json_decode(file_get_contents($json_file_path), true);
    } else {
        $jsoinfo = null;
    }
    // dd($jsoinfo, $un/it_raster_path);
@endphp

@section('content')
    <!-- Top Bar -->

    @include('app.customer_orders.steps.parts.topbar')
    @include('app.customer_orders.steps.parts.order_info')
    @include('app.customer_orders.steps.parts.dimission_info')
    @include('app.customer_orders.steps.parts.street_model')
    @include('app.customer_orders.steps.parts.parcel_model')



    <!-- âœ… Modal HTML -->
    <div id="successModal" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50 hidden">
        <div class="bg-white rounded-lg p-6 shadow-md max-w-md w-full text-center">
            <h2 id="successMessageText" class="text-lg font-semibold text-green-700 mb-4">ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­</h2>
            <button onclick="closeSuccessModal()" class="mt-2 px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">
                Ù…ÙˆØ§ÙÙ‚
            </button>
        </div>
    </div>
    <!-- Map Container -->
    <div id="map"></div>
@endsection




@section('scripts')
    <script>
        function showSuccessModal(message) {
            const modal = document.getElementById("successModal");
            const messageElement = document.getElementById("successMessageText");
            messageElement.textContent = message || "ØªÙ… Ø¨Ù†Ø¬Ø§Ø­";
            modal.classList.remove("hidden");
            modal.classList.add("flex");
        }

        function closeSuccessModal() {
            const modal = document.getElementById("successModal");
            modal.classList.remove("flex");
            modal.classList.add("hidden");
        }




        document.getElementById("uploadForm").addEventListener("submit", function(e) {
            e.preventDefault();
            const file = document.getElementById("csvInput").files[0];
            if (!file) return alert("Please select a CSV file");

            const formData = new FormData();
            formData.append("file", file);

            fetch("{{ route('survey.upload.csv') }}", {
                    method: "POST",
                    headers: {
                        'X-CSRF-TOKEN': '{{ csrf_token() }}'
                    },
                    body: formData
                })
                .then(res => res.json())
                .then(data => {
                    drawGeoFeatures(data.features);
                    document.getElementById("successMessage").classList.remove("hidden");
                    document.getElementById("errorMessages").classList.add("hidden");
                    closeModal();
                    document.getElementById("uploadForm").reset(); // reset form
                })
                .catch(err => {
                    document.getElementById("errorMessages").classList.remove("hidden");
                    document.getElementById("errorMessages").innerText = "Upload failed. Check console.";
                    console.error(err);
                });
        });

        document.getElementById("uploadBtn").addEventListener("click", () => {
            const modal = document.getElementById("uploadModal");
            modal.classList.remove("hidden");
            modal.classList.add("flex");
        });

        function closeStreetModal() {
            const modal = document.getElementById("streetinfoModel");
            modal.classList.remove("flex");
            modal.classList.add("hidden");
        }

        function closeparcelModel() {
            const modal = document.getElementById("parcelModel");
            modal.classList.remove("flex");
            modal.classList.add("hidden");
        }

        function closeModal() {
            const modal = document.getElementById("uploadModal");
            document.getElementById('dimensionsModal').classList.add('hidden');
            modal.classList.remove("flex");
            modal.classList.add("hidden");
        }

        document.addEventListener("DOMContentLoaded", function() {
            const streetBtn = document.getElementById('openStreetInfoBtn');
            const modal = document.getElementById('streetinfoModel');

            if (streetBtn && modal) {
                streetBtn.addEventListener('click', () => {
                    modal.classList.remove('hidden');
                    modal.classList.add('flex');
                });
            }
        });

        function exportGeoJSON() {
            const geojson = drawnItems.toGeoJSON();
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(geojson));
            const dlAnchor = document.createElement('a');
            dlAnchor.setAttribute("href", dataStr);
            dlAnchor.setAttribute("download", "map_data.geojson");
            document.body.appendChild(dlAnchor);
            dlAnchor.click();
            dlAnchor.remove();
        }

        function exportCSV() {
            const geojson = drawnItems.toGeoJSON();
            let csv = "type,lat,lng,code\n";

            geojson.features.forEach(feature => {
                const type = feature.geometry.type;
                const code = feature.properties?.code || '';
                let coords = [];

                if (type === "LineString" || type === "Polygon") {
                    coords = type === "Polygon" ?
                        feature.geometry.coordinates[0] :
                        feature.geometry.coordinates;

                    coords.forEach(([lng, lat], index) => {
                        let posType = 'a';
                        if (index === 0) {
                            posType = 'ab'; // First point
                        } else if (index === coords.length - 1) {
                            posType = 'ac'; // Last point
                        }
                        csv += `${type},${lat},${lng},${posType},${posType}\n`;
                    });
                }
            });

            const blob = new Blob([csv], {
                type: 'text/csv;charset=utf-8;'
            });
            const url = URL.createObjectURL(blob);
            const dlAnchor = document.createElement("a");
            dlAnchor.setAttribute("href", url);
            dlAnchor.setAttribute("download", "map_data.csv");
            document.body.appendChild(dlAnchor);
            dlAnchor.click();
            dlAnchor.remove();
        }
    </script>

    <script>
        const colorMap = {
            'w': 'red',
            'bl': 'blue',
            'a': 'green'
        };

        const rasterImage = @json($unit_raster_path); // Ù‡Ø°Ø§ ÙŠØ­ÙˆÙ„ Ø§Ù„Ø±Ø§Ø¨Ø· Ù„ØµÙŠØºØ© JS
        const boundsData = @json($jsoinfo['bounds'] ?? null); // Ù‡Ø°Ø§ ÙŠØ­ÙˆÙ„ bounds Ø¥Ù„Ù‰ JavaScript Array

        const map = L.map("map", {
            crs: L.CRS.Simple,
            minZoom: -5
        });
        map.editTools = new L.Editable(map); // âœ…

        const snapLayers = new L.FeatureGroup().addTo(map);
        const drawnItems = new L.FeatureGroup().addTo(map);

        if (boundsData && Array.isArray(boundsData)) {
            const bounds = boundsData;
            L.imageOverlay(rasterImage, bounds).addTo(map);
            map.fitBounds(bounds);
        } else {
            console.warn("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ bounds ØµØ§Ù„Ø­Ø©.");
        }

        map.on('editable:drawing:start', function(e) {
            const layer = e.layer;
            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {
                const snapper = new L.Handler.PolylineSnap(map, layer);
                snapLayers.eachLayer(function(guide) {
                    snapper.addGuideLayer(guide);
                });
                snapper.enable();
            }
        });

        drawnItems.on('layeradd', function(e) {
            snapLayers.addLayer(e.layer);
        });

        // âœ… ØªÙØ¹ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø£Ø¯ÙˆØ§Øª leaflet.pm
        map.pm.addControls({
            position: 'topleft',
            drawMarker: true,
            drawCircleMarker: true,
            drawPolyline: true,
            drawRectangle: true,
            drawPolygon: true,
            drawCircle: true,
            editMode: true,
            dragMode: true,
            cutPolygon: true,
            removalMode: true,
            rotateMode: true
        });

        // âœ… ØªÙØ¹ÙŠÙ„ ÙƒÙ„ Ø£Ø¯ÙˆØ§Øª Leaflet.Draw Ø£ÙŠØ¶Ù‹Ø§
        map.addControl(new L.Control.Draw({
            position: 'topright',
            edit: {
                featureGroup: drawnItems,
                edit: true,
                remove: true
            },
            draw: {
                polygon: {
                    allowIntersection: false,
                    showArea: true,
                    shapeOptions: {
                        color: 'purple'
                    }
                },
                polyline: {
                    shapeOptions: {
                        color: 'black',
                        weight: 3
                    }
                },
                rectangle: {
                    shapeOptions: {
                        color: 'green'
                    }
                },
                circle: {
                    shapeOptions: {
                        color: 'red'
                    }
                },
                marker: true,
                circlemarker: true
            }
        }));

        map.on('pm:vertexclick', e => {
            const latlng = e.latlng;
            const layer = e.layer;
            const index = e.indexPath[0]; // index of the clicked point in the coordinates array

            // Ø£Ø¸Ù‡Ø± Ù‚Ø§Ø¦Ù…Ø© Ø®ÙŠØ§Ø±Ø§Øª Ø¨Ø³ÙŠØ·Ø© (Ù…Ø«Ø§Ù„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… confirm):
            const choice = prompt("ğŸ›  Ø§Ø®ØªØ±: \n1: Ø­Ø°Ù Ø§Ù„Ù†Ù‚Ø·Ø©\n2: Ø¥Ø¯Ø±Ø§Ø¬ Ù†Ù‚Ø·Ø© Ø¨Ø¹Ø¯Ù‡Ø§", "1");

            if (choice === "1") {
                // âœ… Ø­Ø°Ù Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
                const coords = layer.getLatLngs();
                if (coords.length <= 2) {
                    alert("âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø§Ù„Ù†Ù‚Ø·Ø©ØŒ Ø£Ù‚Ù„ Ø¹Ø¯Ø¯ Ù‡Ùˆ Ù†Ù‚Ø·ØªÙŠÙ†.");
                    return;
                }

                coords.splice(index, 1); // Ø­Ø°Ù Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©
                layer.setLatLngs(coords); // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª
                layer.redraw();
            } else if (choice === "2") {
                // âœ… Ø¥Ø¯Ø±Ø§Ø¬ Ù†Ù‚Ø·Ø© Ø¬Ø¯ÙŠØ¯Ø© Ø¨ÙŠÙ† Ø§Ù„Ø­Ø§Ù„ÙŠØ© ÙˆØ§Ù„ØªØ§Ù„ÙŠØ© Ø£Ùˆ Ø§Ù„Ù†Ù‡Ø§ÙŠØ©
                const coords = layer.getLatLngs();
                const current = coords[index];
                const next = coords[index + 1] || coords[index - 1];

                if (!next) return;

                const mid = [
                    (current.lat + next.lat) / 2,
                    (current.lng + next.lng) / 2
                ];
                coords.splice(index + 1, 0, L.latLng(mid[0], mid[1])); // Ø£Ø¶Ù Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
                layer.setLatLngs(coords);
                layer.redraw();
            }
        });
        map.on('editable:drawing:start', function(e) {
            const layer = e.layer;
            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {
                // Ù…Ø± Ø¹Ù„Ù‰ ÙƒÙ„ Ø§Ù„Ø¹Ù†Ø§ØµØ± ÙÙŠ drawnItems ÙˆØ£Ø¶ÙÙ‡Ø§ ÙƒÙ€ "snap guides"
                drawnItems.eachLayer(function(guideLayer) {
                    if (guideLayer.editing) {
                        const snapper = new L.Handler.MarkerSnap(map, layer);
                        snapper.addGuideLayer(guideLayer);
                    }
                });
            }
        });


        map.on(L.Draw.Event.CREATED, (e) => {
            const layer = e.layer;

            // âœ… ØªÙ…ÙƒÙŠÙ† Ø§Ù„ØªØ¹Ø¯ÙŠÙ„
            if (layer.pm) {
                layer.pm.enable({
                    allowSelfIntersection: false,
                });
            }

            drawnItems.addLayer(layer);

            // âœ… Ø¥Ø°Ø§ ÙƒØ§Ù† Ø¨ÙˆÙ„ÙŠØ¬ÙˆÙ†ØŒ ÙØ¹Ù‘Ù„ Ø§Ù„Ø­Ø¯Ø« Ù…Ø¨Ø§Ø´Ø±Ø©
            if (layer instanceof L.Polygon) {
                layer.on('dblclick', function(ev) {
                    L.DomEvent.stopPropagation(ev);
                    const modal = document.getElementById("parcelModel");
                    if (modal) {
                        modal.classList.remove("hidden");
                        modal.classList.add("flex");
                    }
                    console.log("âœ… Polygon dblclicked:", layer.getLatLngs());
                });
            }

            // âœ… Polyline logic
            if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
                const coords = layer.getLatLngs();
                const rawCoords = coords.map(latlng => [latlng.lng, latlng.lat]);

                const widthInput = document.getElementById('defaultStreetWidth');
                const width = parseFloat(widthInput?.value || 0);

                const centerOffset = offsetLine(rawCoords, width / 2, 'left');
                const centerLatLngs = centerOffset.map(p => [p[1], p[0]]);
                L.polyline(centerLatLngs, {
                    color: 'red',
                    weight: 5
                }).addTo(drawnItems);

                const leftOffset = offsetLine(rawCoords, width, 'left');
                const leftLatLngs = leftOffset.map(p => [p[1], p[0]]);
                L.polyline(leftLatLngs, {
                    color: 'blue',
                    weight: 3,
                    dashArray: '4 4'
                }).addTo(drawnItems);

                document.getElementById('drawnLineInput').value = JSON.stringify(rawCoords);
                document.getElementById('offsetLineInput').value = JSON.stringify(centerOffset);
                document.getElementById('leftLineInput').value = JSON.stringify(leftOffset);

                const modal = document.getElementById("streetinfoModel");
                if (modal) {
                    modal.classList.remove("hidden");
                    modal.classList.add("flex");
                }
            }
        }); // âœ… Ù†Ù‡Ø§ÙŠØ© map.on(L.Draw.Event.CREATED)

        // âœ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ø¯Ø« Ù„Ø£ÙŠ Ø·Ø¨Ù‚Ø© Ø¨ÙˆÙ„ÙŠØ¬ÙˆÙ† ÙŠØªÙ… ØªØ­Ù…ÙŠÙ„Ù‡Ø§ Ù„Ø§Ø­Ù‚Ù‹Ø§ Ù…Ù† Ø§Ù„Ù€ DB
        drawnItems.on('layeradd', function(e) {
            const layer = e.layer;
            if (layer instanceof L.Polygon) {
                layer.on('dblclick', function(ev) {
                    L.DomEvent.stopPropagation(ev);
                    const modal = document.getElementById("parcelModel");
                    if (modal) {
                        modal.classList.remove("hidden");
                        modal.classList.add("flex");
                    }
                    console.log("âœ… Polygon dblclicked:", layer.getLatLngs());
                });
            }
        });

        map.on(L.Draw.Event.EDITED, function(e) {
            const layers = e.layers;
            const widthInput = document.getElementById('defaultStreetWidth');
            const width = parseFloat(widthInput?.value || 0);

            layers.eachLayer(function(layer) {
                if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
                    const coords = layer.getLatLngs();
                    const rawCoords = coords.map(latlng => [latlng.lng, latlng.lat]);

                    // ğŸ§¼ Ø§Ø­Ø°Ù Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ù…Ø±Ø§ÙÙ‚Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
                    drawnItems.eachLayer(l => {
                        if (l !== layer && l.options && (l.options.color === 'red' || l.options
                                .color === 'blue')) {
                            drawnItems.removeLayer(l);
                        }
                    });

                    // âœ… ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø®Ø· Ø§Ù„Ø£Ø­Ù…Ø± (center offset)
                    const centerOffset = offsetLine(rawCoords, width / 2, 'left');
                    const centerLatLngs = centerOffset.map(p => [p[1], p[0]]);
                    L.polyline(centerLatLngs, {
                        color: 'red',
                        weight: 5,
                        dashArray: '0'
                    }).addTo(drawnItems);

                    // âœ… ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø®Ø· Ø§Ù„Ø£Ø²Ø±Ù‚ (left offset)
                    const leftOffset = offsetLine(rawCoords, width, 'left');
                    const leftLatLngs = leftOffset.map(p => [p[1], p[0]]);
                    L.polyline(leftLatLngs, {
                        color: 'blue',
                        weight: 3,
                        dashArray: '4 4'
                    }).addTo(drawnItems);

                    // âœ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ø®ÙÙŠØ©
                    document.getElementById('drawnLineInput').value = JSON.stringify(rawCoords);
                    document.getElementById('offsetLineInput').value = JSON.stringify(centerOffset);
                    document.getElementById('leftLineInput').value = JSON.stringify(leftOffset);
                }
            });
        });
        // âœ… Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹ Ù„Ù„Ù†Ù‚Ø± Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬ Ø¹Ù„Ù‰ Ø£ÙŠ Ø¹Ù†ØµØ± Ø¨ÙˆÙ„ÙŠØ¬ÙˆÙ†
    </script>

    <script>
        const initialGeoJson = {!! $geojson !!};

        setTimeout(() => {
            if (initialGeoJson && initialGeoJson.features) {
                console.log("Drawing saved features from DB...");
                drawGeoFeatures(initialGeoJson.features);
            } else {
                console.warn("initialGeoJson is not a valid FeatureCollection:", initialGeoJson);
            }
        }, 3000);

        function computeLineLengthXY(coordsXY) {
            let length = 0;
            for (let i = 0; i < coordsXY.length - 1; i++) {
                const [x1, y1] = coordsXY[i];
                const [x2, y2] = coordsXY[i + 1];
                length += Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            }
            return length;
        }

        function getMidpoint(coordsXY) {
            let sumX = 0,
                sumY = 0;
            coordsXY.forEach(([x, y]) => {
                sumX += x;
                sumY += y;
            });
            const n = coordsXY.length;
            return [sumX / n, sumY / n];
        }

        function drawGeoFeatures(features) {
            if (!Array.isArray(features)) {
                console.error("âŒ Expected an array of features, but got:", features);
                return;
            }

            features.forEach(feature => {
                const code = feature.properties.code || '';
                const color = colorMap[code] || 'green';

                if (feature.geometry.type === "LineString") {
                    const coordsXY = feature.geometry.coordinates;
                    const length = computeLineLengthXY(coordsXY).toFixed(2);
                    const coordsLatLng = coordsXY.map(p => [p[1], p[0]]);

                    const line = L.polyline(coordsLatLng, {
                        color,
                        weight: 3
                    }).addTo(drawnItems);

                    // âœ… ØªÙ…ÙƒÙŠÙ† Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… leaflet.pm
                    if (line.pm) {
                        line.pm.enable({
                            allowSelfIntersection: false
                        });
                    }

                    const [midX, midY] = getMidpoint(coordsXY);
                    const label = L.marker([midY, midX], {
                        icon: L.divIcon({
                            className: 'line-label',
                            html: `${code}<br>-: ${length}`
                        })
                    }).addTo(drawnItems);

                    line.bindPopup(`${code}-: ${length}`);
                } else if (feature.geometry.type === "Polygon") {
                    const coordsXY = feature.geometry.coordinates[0];
                    const coordsLatLng = coordsXY.map(p => [p[1], p[0]]);
                    const polygon = L.polygon(coordsLatLng, {
                        color,
                        fillOpacity: 0.3
                    }).addTo(drawnItems);

                    // âœ… Ø­Ø¯Ø« Ø§Ù„Ù†Ù‚Ø± Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬
                    polygon.on('dblclick', function(e) {
                        L.DomEvent.stopPropagation(e); // Ù„Ù…Ù†Ø¹ Ø§Ù„Ø²ÙˆÙ… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ

                        // âœ… ÙØªØ­ Ø§Ù„Ù…ÙˆØ¯Ø§Ù„
                        const modal = document.getElementById("parcelModel");
                        if (modal) {
                            modal.classList.remove("hidden");
                            modal.classList.add("flex");
                        }

                        // âœ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø´ÙƒÙ„ ÙˆØ·Ø¨Ø§Ø¹ØªÙ‡Ø§ ÙÙŠ Ø§Ù„ÙƒÙˆÙ†Ø³ÙˆÙ„
                        const center = polygon.getBounds().getCenter();
                        console.log("âœ… Polygon clicked:");
                        console.log("ğŸ§­ Center:", center);
                        console.log("ğŸ“Œ Coordinates (LatLng):", coordsLatLng);
                        console.log("ğŸ”– Code:", code);
                        console.log("ğŸ“ Type:", feature.geometry.type);
                    });
                }

            });
        }


        function offsetLine(coords, offsetDistance, direction = 'left') {
            const offsetCoords = [];
            const multiplier = direction === 'left' ? 1 : -1;

            for (let i = 0; i < coords.length - 1; i++) {
                const [x1, y1] = coords[i];
                const [x2, y2] = coords[i + 1];

                const dx = x2 - x1;
                const dy = y2 - y1;

                const length = Math.sqrt(dx ** 2 + dy ** 2);
                if (length === 0) continue;

                const nx = -dy / length;
                const ny = dx / length;

                const offsetStart = [
                    x1 + multiplier * offsetDistance * nx,
                    y1 + multiplier * offsetDistance * ny
                ];
                const offsetEnd = [
                    x2 + multiplier * offsetDistance * nx,
                    y2 + multiplier * offsetDistance * ny
                ];

                if (i === 0) offsetCoords.push(offsetStart);
                offsetCoords.push(offsetEnd);
            }

            return offsetCoords;
        }




        function saveStreetinfo(event) {
            event.preventDefault(); // Prevent default form submission

            let form = document.getElementById('saveStreetinfoForm');
            if (!form) {
                console.error("Form not found in the DOM!");
                return;
            }

            let formData = new FormData(form);
            let postUrl = document.getElementById('postRoute')?.value;

            if (!postUrl) {
                console.error("Post URL not found!");
                return;
            }

            // Clear previous errors
            document.querySelectorAll(".error-message").forEach(el => el.remove());

            fetch(postUrl, {
                    method: "POST",
                    headers: {
                        "X-CSRF-TOKEN": "{{ csrf_token() }}"
                    },
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        closeStreetModal();

                        showSuccessModal(data.message);
                        let successContainer = document.getElementById("successMessage");
                        successContainer.classList.remove("hidden");



                        // Refresh page after success
                        setTimeout(function() {
                            location.reload();
                        }, 6000);
                    } else if (data.errors) {

                        if (typeof data.errors === 'string') {
                            showNotification(data.errors, data.errors, 'error', 100);
                            return;
                        }
                        // Show validation errors below the respective input fields
                        Object.keys(data.errors).forEach(field => {
                            let inputField = document.querySelector(`[name="${field}"]`);
                            if (inputField) {
                                let errorElement = document.createElement("p");
                                errorElement.textContent = data.errors[field][0]; // Show first error
                                errorElement.classList.add("error-message", "text-red-500", "text-sm", "mt-1");
                                inputField.insertAdjacentElement("afterend", errorElement);
                            }
                        });
                    }
                })
                .catch(error => console.error('Error submitting form:', error));
        }


        function showNotification(title, message, type = 'info', duration = 3000) {
            const notif = document.createElement('div');
            notif.className =
                `fixed top-4 right-4 px-4 py-2 rounded shadow-md text-white bg-${type === 'success' ? 'green' : type === 'error' ? 'red' : 'blue'}-500`;
            notif.textContent = `${title}: ${message}`;
            document.body.appendChild(notif);

            setTimeout(() => {
                notif.remove();
            }, duration || 5000);
        }
    </script>
@endsection
