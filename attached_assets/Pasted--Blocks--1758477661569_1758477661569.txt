مهمتنا التالية هي تحديث وتحسين عملية إدخال بيانات "البلوكات" (Blocks) في نظام المعلومات الجغرافية الخاص بنا. سنقوم بتطبيق نفس المنهجية الناجحة التي استخدمناها مع "الوحدات الجوارية"، مع إضافة تحسينين استراتيجيين.
الأهداف الرئيسية:
إصلاح معرّف البلوك: استبدال الأسماء غير الواضحة بمعرّف فريد ومفهوم.
توليد رمز مخصص: إنشاء رمز مركب وفريد لكل بلوك على مستوى النظام.
إثراء البيانات: تعيين قيمة افتراضية لنوع البلوك لضمان اكتمال البيانات.
ملفات وبيانات العمل:
ملف الإدخال: blocksfinal_1758314630359.geojson
العمود المرجعي للاسم: Id (من ملف GeoJSON)
العمود المرجعي للنوع: tepe (من ملف GeoJSON)
ملف السكريبت للتعديل: scripts/seed-geo-data.ts (تحديداً الدالة المسؤولة عن إدخال البلوكات، seedBlocks).
جدول قاعدة البيانات: blocks
خطة التنفيذ المفصلة (مقسمة إلى خطوات):
الخطوة 1: تعديل دالة seedBlocks في scripts/seed-geo-data.ts
قم بتعديل الدالة لتنفيذ المنطق التالي:
تحضير عدّاد تسلسلي: قبل بدء حلقة التكرار (loop) على البلوكات، قم بإنشاء كائن Map أو object فارغ لتخزين آخر رقم تسلسلي تم استخدامه لكل وحدة جوار. مثال: const blockCounters = new Map<string, number>();
داخل حلقة التكرار لكل بلوك:
الربط المكاني: أولاً، حدد neighborhoodUnitId الذي ينتمي إليه البلوك الحالي باستخدام نفس استراتيجية الربط المكاني (Spatial Intersection) التي تم الاتفاق عليها مسبقًا.
توليد الرمز المركب (block_code):
احصل على رمز الوحدة الجوارية (e.g., unit.code) التي تم ربط البلوك بها.
احصل على الرقم التسلسلي الحالي لتلك الوحدة من blockCounters. إذا لم يكن موجودًا، ابدأ من 0.
قم بزيادة العداد بمقدار 1.
قم بإنشاء الرمز المركب بالصيغة: '${unit.code}-${newCounter}'. مثال: '287-1'.
قم بتحديث قيمة العداد في blockCounters للوحدة الحالية.
تحديد نوع البلوك (blockType):
اقرأ قيمة خاصية tepe من ملف GeoJSON.
إذا كانت القيمة null أو غير موجودة، قم بتعيين قيمة افتراضية هي 'residential'.
إذا كانت القيمة موجودة، استخدمها كما هي.
تحديث عملية الإدراج (db.insert):
عند إدراج البلوك في قاعدة البيانات، استخدم القيم الجديدة التي قمت بتوليدها:
code: استخدم الرمز المركب الذي تم إنشاؤه.
name_ar: يمكنك استخدام الرمز المركب أيضًا أو Id من الملف، ولكن code هو الأهم.
blockType: استخدم القيمة التي حددتها (إما من الملف أو القيمة الافتراضية 'residential').
الخطوة 2: حذف بيانات البلوكات القديمة
قم بتنفيذ استعلام SQL لمسح جدول blocks بالكامل لضمان عدم وجود بيانات قديمة.
DELETE FROM blocks;
الخطوة 3: إعادة تشغيل السكريبت والتحقق
قم بتشغيل سكريبت seed-geo-data.ts المحدّث لإعادة إدخال جميع البلوكات بالمنطق الجديد.
بعد اكتمال التنفيذ، قم بإجراء استعلام تحقق (SQL query) على عينة من البيانات للتأكد من أن:
عمود code يحتوي على رموز مركبة وفريدة (مثل 287-1, 287-2, 288-1).
عمود blockType لا يحتوي على أي قيم null، وأن القيم الفارغة سابقًا أصبحت الآن 'residential'.



استراتيجية محسّنة للأداء (Optimized Strategy)
للتغلب على هذه التحديات مع 36,000 بلوك، لا يمكننا استخدام النهج البسيط (حلقة تكرار مع استعلام لكل عنصر). يجب أن ننتقل إلى نهج أكثر احترافية يعتمد على قوة قاعدة البيانات.
الاستراتيجية المُحسّنة: تنفيذ العملية كلها داخل استعلام SQL واحد ضخم (Single, Bulk SQL Query).
بدلاً من سحب البيانات إلى Node.js ثم إرسالها مرة أخرى إلى قاعدة البيانات، سنجعل قاعدة البيانات (PostGIS) تقوم بكل العمل الشاق دفعة واحدة.
فكرة الاستعلام:
إدخال جميع البلوكات دفعة واحدة: أولاً، نقوم بإدخال جميع بيانات البلوكات الـ 36,000 من ملف GeoJSON إلى جدول مؤقت (temporary table) أو إلى الجدول النهائي مباشرة مع ترك neighborhood_unit_id فارغًا.
تنفيذ استعلام UPDATE واحد للربط: بعد ذلك، ننفذ استعلام UPDATE واحد يقوم بربط جميع البلوكات بوحداتها الجوارية.
مثال مبسط لشكل استعلام التحديث (Conceptual SQL):
SQL
-- هذه نسخة مبسطة لتوضيح الفكرة، الاستعلام الحقيقي سيكون أكثر تعقيدًا
WITH BlockUnitMapping AS (
  -- هذا الجزء يحدد أفضل وحدة جوار لكل بلوك
  SELECT
    b.id AS block_id,
    -- استخدم DISTINCT ON لاختيار وحدة الجوار ذات أكبر مساحة تقاطع فقط
    DISTINCT ON (b.id) nu.id AS best_unit_id,
    nu.code AS unit_code
  FROM
    blocks b
  JOIN
    neighborhood_units nu ON ST_Intersects(b.geom, nu.geom)
  ORDER BY
    b.id,
    -- ترتيب النتائج لكل بلوك حسب مساحة التقاطع (الأكبر أولاً)
    ST_Area(ST_Intersection(b.geom, nu.geom)) DESC
)
-- الآن، قم بتحديث جدول البلوكات بناءً على النتائج أعلاه
UPDATE blocks b
SET
  neighborhood_unit_id = bum.best_unit_id,
  -- توليد الرمز المركب باستخدام Window Functions لتوليد الأرقام التسلسلية
  code = bum.unit_code || '-' || ROW_NUMBER() OVER(PARTITION BY bum.best_unit_id ORDER BY b.id)
FROM
  BlockUnitMapping bum
WHERE
  b.id = bum.block_id;
لماذا هذا الحل أفضل بكثير؟
السرعة: قاعدة البيانات مُحسَّنة للغاية للتعامل مع مجموعات كبيرة من البيانات (Set-based operations). تنفيذ هذا كاستعلام واحد سيكون أسرع بـ 100 مرة (أو أكثر) من النهج التكراري.
كفاءة الموارد: يقلل من نقل البيانات بين التطبيق وقاعدة البيانات، ويستخدم ذاكرة أقل.
الموثوقية: يتم تنفيذ العملية كلها كوحدة واحدة (atomic transaction)، مما يقلل من فرص حدوث أخطاء في منتصف الطريق.