⚠️ الملاحظات الحرجة التي يجب تعديلها
1. ❌ المشكلة الكبرى: حذف عمود role من جدول users
هذا خطأ استراتيجي — وليس تقنياً.

لماذا؟
النظام الحالي يعمل — ولا يمكنك تعطيله أثناء الترقية.
المستخدمون الحاليون لديهم أدوار — وإذا حذفت العمود — ستفقد كل هذه البيانات.
التطبيقات الخارجية قد تعتمد عليه — مثل تطبيق DreamFlow.
✅ الحل الذكي: الاحتفاظ بـ role كحقل احتياطي (Deprecated)
TypeScript

// shared/schema.ts
export const users = pgTable("users", {
  // ... الأعمدة الأخرى
  role: text("role").notNull().default("citizen"), // ← احتفظ به مؤقتاً
  // ... الأعمدة الجديدة
});
📌 خطة الهجرة:

أضف الجداول الجديدة (roles, permissions, ...) دون حذف role.
أنشئ migration لتحويل بيانات role إلى userRoles.
بعد التأكد من أن كل شيء يعمل — أزل role في إصدار مستقبلي.
2. ❌ المشكلة الثانية: التحقق من الصلاحيات عبر JOIN واحد معقد
هذا غير فعال — وسيسبب بطئاً عند نمو عدد المستخدمين.

لماذا؟
كل طلب API سيحتاج JOIN بين 4 جداول:
SQL

SELECT p.code 
FROM userRoles ur
JOIN roles r ON ur.roleId = r.id
JOIN rolePermissions rp ON r.id = rp.roleId
JOIN permissions p ON rp.permissionId = p.id
WHERE ur.userId = ?
هذا سيكون بطيئاً جداً إذا كان لديك 10,000 مستخدم.
✅ الحل الذكي: تخزين الصلاحيات في JWT Token
TypeScript

// عند تسجيل الدخول — جلب الصلاحيات مرة واحدة فقط
const permissions = await db
  .select({ code: permissions.code })
  .from(userRoles)
  .innerJoin(roles, eq(userRoles.roleId, roles.id))
  .innerJoin(rolePermissions, eq(roles.id, rolePermissions.roleId))
  .innerJoin(permissions, eq(rolePermissions.permissionId, permissions.id))
  .where(eq(userRoles.userId, userId));

// إضافتها إلى الـ JWT
const token = jwt.sign({
  id: user.id,
  username: user.username,
  permissions: permissions.map(p => p.code), // ← تخزين الصلاحيات هنا
}, SECRET_KEY);
ثم في middleware:

TypeScript

// التحقق من الصلاحية — بدون استعلام قاعدة بيانات!
if (!req.user.permissions.includes(permissionCode)) {
  return res.status(403).json({ error: "Forbidden" });
}
next();
✅ المؤشر: زمن التحقق من الصلاحيات < 1ms — حتى مع مليون مستخدم.

3. ❌ المشكلة الثالثة: عدم وجود "صلاحية افتراضية" (Default Permissions)
ما الذي يحدث إذا لم يتم تعيين أي صلاحيات لدور جديد؟

✅ الحل الذكي: إضافة آلية "الحد الأدنى من الصلاحيات"
TypeScript

// عند إنشاء دور جديد — منحه صلاحيات أساسية
const DEFAULT_PERMISSIONS = [
  'profile.view',
  'notifications.read'
];

await db.insert(rolePermissions).values(
  defaultPermissions.map(p => ({
    roleId: newRoleId,
    permissionId: p.id
  }))
);
هذا يضمن أن كل دور — حتى لو كان جديداً — لديه صلاحيات أساسية للعمل.

