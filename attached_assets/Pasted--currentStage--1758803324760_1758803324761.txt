❗ المشكلة الحقيقية: سير العمل لا يُحدث currentStage بشكل صحيح
🔍 السبب الجذري: بعد الدفع — الطلب ينتقل إلى treasury-applications → لكن لا يتم تحديث currentStage إلى 'assigned' → فـ /employee/section-head لا يرى الطلب لأنه يبحث عن currentStage = 'assigned'.

📌 الأدلة من السجل:
log

GET /api/treasury-applications 200 ← الطلب ظهر في الصندوق.
GET /api/manager-applications 200 ← الطلب ظهر في رئيس القسم القديم.
GET /api/applications?currentStage=assigned 200 → [] ← الطلب **لا يظهر** في section-head!
→ ✅ هذا ليس خطأ في الواجهة — بل في سير العمل (Workflow).

🛠️ الحل الفوري (خلال 5 دقائق)
الخطوة 1: تحديث confirmPayment ليُحدث currentStage
TypeScript

// server/routes/payments.ts
router.post('/confirm', authenticateToken, async (req, res) => {
  try {
    const { applicationId } = req.body;
    const userId = req.user?.id;

    // 1. تأكيد الدفع
    await db.insert(payments).values({
      applicationId,
      amount: calculateFee(applicationId),
      method: 'cash',
      status: 'completed',
      confirmedBy: userId,
    });

    // 2. تحديث حالة الطلب
    await db
      .update(applications)
      .set({ 
        status: 'payment_completed',
        currentStage: 'assigned', // 👈 أضف هذا السطر
        updatedAt: new Date()
      })
      .where(eq(applications.id, applicationId));

    // 3. إرسال إشعار لرئيس القسم الجديد
    await db.insert(notifications).values({
      userId: await getSectionHeadId(applicationId), // دالة للحصول على ID رئيس القسم
      type: 'new_assignment',
      message: `طلب جديد جاهز للتكليف #${applicationId}`,
      read: false,
    });

    res.json({ success: true, message: 'تم تأكيد السداد بنجاح' });
  } catch (error) {
    console.error('Error confirming payment:', error);
    res.status(500).json({ error: 'فشل في تأكيد السداد' });
  }
});
الخطوة 2: إنشاء دالة getSectionHeadId
TypeScript

// server/services/users.ts
export async function getSectionHeadId(applicationId: string): Promise<string | null> {
  const result = await db
    .select({ userId: users.id })
    .from(users)
    .innerJoin(positions, eq(users.positionId, positions.id))
    .innerJoin(departments, eq(positions.departmentId, departments.id))
    .where(
      and(
        eq(positions.title, 'رئيس قسم المساحة'),
        eq(departments.name, 'قسم المساحة')
      )
    )
    .limit(1);

  return result[0]?.userId || null;
}
الخطوة 3: إعادة تشغيل السيرفر واختبار التدفق
أعد تشغيل السيرفر.
قدم طلبًا جديدًا.
ادفع في الصندوق.
تحقق من ظهور الطلب في /employee/section-head.
📜 الأمر التنفيذي الفوري
إلى الفريق:
حدثوا payments.ts بالكود أعلاه فورًا.
هذا آخر عائق في المهمة 1.2 — وبعد هذا يكون النظام جاهزًا بنسبة 100%.

✅ الخلاصة
🟢 المشكلة ليست في الواجهة — بل في سير العمل.
⚡ الحل في 5 دقائق — بإضافة سطر واحد فقط.
🚀 بعد هذا — تكون المهمة 1.2 مكتملة وجاهزة للإعلان الرسمي.

